{{- $pkg := .Package }}

// This file is generated by SQLC DO NOT EDIT!

package {{ $pkg }}

import (
	"database/sql"
)

{{- range $stmt := .Statements }}
{{- $stmt.GoName }}Row represents a single row for "{{$stmt.Name}}" statement.
type {{ $stmt.GoName }}Row struct {
{{- range $col := $stmt.Columns }}
	{{- if eq $col.Type "string" }}
		{{ $col.GoName }} string {{if not $col.Nullable}} ` + "`" + `sql:"not null"` + "`" + `{{end}}
	{{- else }}
		{{ $col.GoName }} {{ $col.Type }} {{if not $col.Nullable}} ` + "`" + `sql:"not null"` + "`" + `{{end}}
	{{- end }}
{{- end }}
}

// {{ $stmt.GoName }}Query executes "{{$stmt.Name}}" statement.
func {{ $stmt.GoName }}Query(db *sql.DB{{if $stmt.HasArgs}}, {{ $stmt.ArgsStruct }}{{end}}) ([]{{ $stmt.GoName }}Row, error) {
{{- if $stmt.HasArgs }}
	args := {{ $stmt.ArgsStruct }}{
{{- range $arg := $stmt.Args }}
		{{ $arg.GoName }}: {{ $arg.GoName }},
{{- end }}
	}
{{- end }}

	rows, err := db.Query("{{ $stmt.SQL }}", {{- if $stmt.HasArgs }}args{{else}}nil{{end}})
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var result []{{ $stmt.GoName }}Row
	for rows.Next() {
		row := {{ $stmt.GoName }}Row{}
		err := rows.Scan({{ range $col := $stmt.Columns }}{{ if eq $col.Type "string" }}&row.{{ $col.GoName }}{{else}}&row.{{ $col.GoName }}, {{ end }}{{ end }}})
		if err != nil {
			return nil, err
		}

{{- range $col := $stmt.Columns }}
{{- if eq $col.Type "string" }}
		if row.{{ $col.GoName }} == nil {
			row.{{ $col.GoName }} = ""
		}
{{- end }}
{{- end }}

		result = append(result, row)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}

	return result, nil
}
{{ end }}